import type { NextPage } from "next";
import * as THREE from "three";

import Image from "next/image";
import { Suspense, useRef, useState } from "react";
import {
  Preload,
  ScrollControls,
  Scroll,
  useScroll,
  Image as ImageImpl,
  useBounds,
  Sparkles,
} from "@react-three/drei";

import {
  Points,
  PointMaterial,
  FlyControls,
  Stars,
  Cloud,
  Sphere,
  Sky,
  ContactShadows,
} from "@react-three/drei";
import * as random from "maath/random";
import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader";
import { Canvas, useFrame, useLoader } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { motion } from "framer-motion";

import Intersection from "../../components/Intersection";
// import images from "../../constants/images";

const scaleVariants = {
  whileInView: {
    scale: [0, 1],
    opacity: [0, 1],
    transition: {
      duration: 1,
      ease: "easeInOut",
    },
  },
};

// const Banner = () => (
//   <motion.div
//     whileInView={scaleVariants.whileInView}
//     className="app__header-circles"
//   >
//     {[images.node, images.react, images.typescript].map((circle, index) => (
//       <div className="circle-cmp app__flex" key={`circle-${index}`}>
//         <Image src={circle} alt="circle" />
//       </div>
//     ))}
//   </motion.div>
// );

// function Pika() {
//   const gltf = useLoader(MTLLoader, './Pikachu.mtl')
//   console.log({ gltf });

//   return <primitive object={gltf} />

// }

function Box(props: any) {
  // This reference will give us direct access to the mesh
  const mesh = useRef({ rotation: { x: 0 } });
  // Set up state for the hovered and active state
  const [hovered, setHover] = useState(false);
  const [active, setActive] = useState(false);
  // Subscribe this component to the render-loop, rotate the mesh every frame
  useFrame((state, delta) => (mesh.current.rotation.x += 0.01));
  // Return view, these are regular three.js elements expressed in JSX
  return (
    <mesh
      {...props}
      ref={mesh}
      scale={1}
      onClick={(event) => setActive(!active)}
      onPointerOver={(event) => setHover(true)}
      onPointerOut={(event) => setHover(false)}
    >
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color={hovered ? "hotpink" : "orange"} />
    </mesh>
  );
}

// function Stars(props: any) {
//   const ref = useRef({ rotation: { x: 0, y: 0 }})
//   const [sphere] = useState(() => random.inSphere(new Float32Array(5000), { radius: 1.5 }))

//   useFrame((state, delta) => {
//     ref.current.rotation.x -= delta / 10
//     ref.current.rotation.y -= delta / 15
//   })

//   return (
//     <group rotation={[0, 0, Math.PI / 4]}>
//       <Points ref={ref} positions={sphere} stride={3} frustumCulled={false} {...props}>
//         <PointMaterial transparent color="" size={0.005} sizeAttenuation={true} depthWrite={false} />
//       </Points>
//     </group>
//   )
// }

export const Scene = (props: any) => (
  <Canvas
    camera={{ position: [0, 0, 0] }}
    style={{ position: "fixed", left: 0, top: 0 }}
  >
    {props.dark ? (
      <Stars />
    ) : (
      <>
        {/* <Sky /> */}
        <Sparkles
          color="#000"
          opacity={0.5}
          speed={1} // Rotation speed
          count={200} // Number of particles
        />
      </>
    )}
  </Canvas>
);

export const Scene2 = () => (
  <Canvas>
    <ambientLight />
    <pointLight position={[10, 10, 10]} />
  </Canvas>
);

export function ScrollScene() {
  return (
    <Canvas gl={{ antialias: false }} dpr={[1, 1.5]}>
      <Suspense fallback={null}>
        <ScrollControls damping={4} pages={3}>
          <Scroll html>
            <h1 style={{ position: "absolute", top: "60vh", left: "0.5em" }}>
              to
            </h1>
            <h1 style={{ position: "absolute", top: "120vh", left: "60vw" }}>
              be
            </h1>
            <h1
              style={{
                position: "absolute",
                top: "198.5vh",
                left: "0.5vw",
                fontSize: "40vw",
              }}
            >
              home
            </h1>
          </Scroll>
        </ScrollControls>
        <Preload />
      </Suspense>
    </Canvas>
  );
}

interface GLTFResult {
  nodes: { [key: string]: any };
  materials: { [key: string]: any };
}

// Auto-generated by: https://github.com/pmndrs/gltfjsx
export function Model({ url, ...props }: { url: any }) {
  const group = useRef<any>();
  const { nodes, materials } = useGLTF<any>(url) as unknown as GLTFResult;
  useFrame((state) => {
    group?.current &&
      group.current?.children &&
      group?.current?.children.forEach((child: any, index: any) => {
        child.position.y +=
          Math.sin(index * 1000 + state.clock.elapsedTime) / 50;
        child.rotation.x +=
          (Math.sin(index * 1000 + state.clock.elapsedTime) * Math.PI) / 2000;
        child.rotation.y +=
          (Math.cos(index * 1000 + state.clock.elapsedTime) * Math.PI) / 3000;
        child.rotation.z +=
          (Math.sin(index * 1000 + state.clock.elapsedTime) * Math.PI) / 4000;
      });
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <mesh
        material={materials.M_Headphone}
        geometry={nodes.Headphones.geometry}
        position={[20.22, 1.99, 4.03]}
        rotation={[1.55, 0.32, -0.76]}
      />
      <mesh
        material={materials.M_Notebook}
        geometry={nodes.Notebook.geometry}
        position={[-21.4, -14.96, -13.21]}
        rotation={[1.83, -0.23, 0.91]}
      />
      <mesh
        material={materials.M_Rocket}
        geometry={nodes.Rocket003.geometry}
        position={[17.58, 15.26, -25.21]}
        rotation={[1.14, 0.81, 0.44]}
      />

      <mesh
        material={materials.M_Headset}
        geometry={nodes.VR_Headset.geometry}
        position={[6.92, -15.17, 27.59]}
        rotation={[1.29, 0.08, -0.64]}
        scale={[5, 5, 5]}
      />
    </group>
  );
}

function ModelMesh({ name, ...props }: any) {
  const { nodes } = useGLTF("/compressed.glb") as unknown as GLTFResult;
  return (
    <mesh
      geometry={nodes[name].geometry}
      material={nodes[name].material}
      material-emissive="red"
      material-roughness={1}
      {...props}
      dispose={null}
    />
  );
}

// This component wraps children in a group with a click handler
// Clicking any object will refresh and fit bounds
function SelectToZoom({ children }: any) {
  const api = useBounds();
  return (
    <group
      onClick={(e: any) => (
        e.stopPropagation(), e.delta <= 2 && api.refresh(e?.object).fit()
      )}
      onPointerMissed={(e) => e.button === 0 && api.refresh().fit()}
    >
      {children}
    </group>
  );
}

export function useRig() {
  const ref = useRef<any>();
  useFrame((state) => {
    ref.current.rotation.y = THREE.MathUtils.lerp(
      ref.current.rotation.y,
      (state.mouse.x * Math.PI) / 20,
      0.05
    );
    ref.current.rotation.x = THREE.MathUtils.lerp(
      ref.current.rotation.x,
      (state.mouse.y * Math.PI) / 20,
      0.05
    );
  });

  return ref;
}

function Rig({ children }: any) {
  const ref = useRig();
  return <group ref={ref}>{children}</group>;
}

export function Lollo() {
  return (
    <Canvas camera={{ position: [0, -10, 65], fov: 50 }} dpr={[1, 2]}>
      <pointLight position={[100, 100, 100]} intensity={0.8} />
      <hemisphereLight
        color="#ffffff"
        groundColor="#b9b9b9"
        position={[-7, 25, 13]}
        intensity={0.85}
      />
      <Suspense fallback={null}>
        <group position={[0, 10, 0]}>
          <Rig>
            <Model url="/compressed.glb" />
          </Rig>
        </group>
      </Suspense>
    </Canvas>
  );
}
